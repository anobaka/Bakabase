name: debug-git-cliff

on:
  workflow_dispatch:
  push:
    branches:
      - debug-actions
jobs:
  debug-git-cliff:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get NBGV version info
        id: nbvg
        uses: dotnet/nbgv@master
        with:
          setAllVars: true

      - name: Export current version
        id: current
        run: |
          echo "current_version=${{ env.NBGV_CloudBuildNumber }}" >> $GITHUB_OUTPUT

      - name: Find previous release tag
        id: previous
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const current = "${{ steps.current.outputs.current_version }}";
            const { owner, repo } = context.repo;
            const releases = await github.paginate(github.rest.repos.listReleases, { owner, repo, per_page: 100 });
            const stable = releases.filter(r => !r.draft && !r.prerelease && r.tag_name && r.tag_name !== current);
            let prev = stable[0]?.tag_name;
            if (!prev && releases.length > 0) {
              prev = releases.find(r => r.tag_name && r.tag_name !== current)?.tag_name;
            }
            if (!prev) {
              const { execSync } = require('node:child_process');
              try {
                prev = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
              } catch {}
            }
            if (!prev) {
              throw new Error('No previous tag found from releases or tags');
            }
            core.setOutput('previous_tag', prev);

      - name: Generate initial context (git-cliff)
        id: cliff_initial
        uses: orhun/git-cliff-action@v4
        with:
          config: cliff.toml
          args: -v ${{ steps.previous.outputs.previous_tag }}..${{ github.sha }} --context
        env:
          OUTPUT: cliff.context.initial.json

      - name: Build issues context
        id: ctx
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const fs = require('node:fs');
            const path = 'cliff.context.initial.json';
            const text = fs.readFileSync(path, { encoding: 'utf8' });
            const initial = JSON.parse(text || '{}');

            const issues = {};
            const issues_meta = {};
            const commitIssues = {};
            const { owner, repo } = context.repo;

            const numberSet = new Set();
            for (const commit of Array.isArray(initial.commits) ? initial.commits : []) {
              const links = Array.isArray(commit.links) ? commit.links : [];
              for (const link of links) {
                const m = /#(\d+)/.exec(link.text || '');
                if (m) {
                  numberSet.add(m[1]);
                }
              }
            }

            for (const num of numberSet) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: Number(num) });
                const info = { title: data.title, url: data.html_url, number: data.number, state: data.state };
                issues[num] = info.title;
                issues['#' + num] = info.title;
                issues_meta[num] = info;
                issues_meta['#' + num] = info;
              } catch (e) {
                core.warning(`Failed to fetch issue #${num}: ${e.message}`);
              }
            }

            for (const commit of Array.isArray(initial.commits) ? initial.commits : []) {
              const links = Array.isArray(commit.links) ? commit.links : [];
              const list = [];
              for (const link of links) {
                const m = /#(\d+)/.exec(link.text || '');
                if (m) {
                  const n = m[1];
                  const meta = issues_meta[n] || issues_meta['#' + n] || null;
                  list.push({ number: n, key: '#' + n, title: meta?.title || '', url: meta?.url || '' });
                }
              }
              const commitId = commit.id || commit.sha || '';
              if (commitId) {
                commitIssues[commitId] = list;
              }
            }

            const enriched = { ...initial, issues, issues_meta, commit_issues: commitIssues };
            const json = JSON.stringify(enriched);
            fs.writeFileSync('cliff.context.enriched.json', json);
            core.setOutput('context', json);
            core.setOutput('context_path', 'cliff.context.enriched.json');
            console.log(enriched);

      - name: Generate final changelog (with context)
        id: cliff_final
        uses: orhun/git-cliff-action@v4
        with:
          config: cliff.toml
          args: --from-context cliff.context.enriched.json
        env:
          OUTPUT: CHANGELOG.final.md

      - name: Print outputs
        run: |
          echo 'Current version: ${{ steps.current.outputs.current_version }}'
          echo 'Previous tag: ${{ steps.previous.outputs.previous_tag }}'
          echo '--- Initial context ---'
          sed -n '1,120p' cliff.context.initial.json | cat
          echo '--- Enriched context ---'
          sed -n '1,120p' cliff.context.enriched.json | cat
          echo '--- Final ---'
          sed -n '1,120p' CHANGELOG.final.md | cat


